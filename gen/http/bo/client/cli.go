// Code generated by goa v3.7.3, DO NOT EDIT.
//
// bo HTTP client CLI support package
//
// Command:
// $ goa gen webcup/design

package client

import (
	"encoding/json"
	"fmt"
	"strconv"
	bo "webcup/gen/bo"

	goa "goa.design/goa/v3/pkg"
)

// BuildGetBoUsersPayload builds the payload for the bo getBoUsers endpoint
// from CLI flags.
func BuildGetBoUsersPayload(boGetBoUsersOffset string, boGetBoUsersLimit string, boGetBoUsersField string, boGetBoUsersDirection string, boGetBoUsersOauth string, boGetBoUsersJWTToken string) (*bo.GetBoUsersPayload, error) {
	var err error
	var offset int32
	{
		var v int64
		v, err = strconv.ParseInt(boGetBoUsersOffset, 10, 32)
		offset = int32(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for offset, must be INT32")
		}
	}
	var limit int32
	{
		var v int64
		v, err = strconv.ParseInt(boGetBoUsersLimit, 10, 32)
		limit = int32(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for limit, must be INT32")
		}
	}
	var field string
	{
		if boGetBoUsersField != "" {
			field = boGetBoUsersField
		}
	}
	var direction string
	{
		if boGetBoUsersDirection != "" {
			direction = boGetBoUsersDirection
			if !(direction == "asc" || direction == "desc") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("direction", direction, []interface{}{"asc", "desc"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var oauth *string
	{
		if boGetBoUsersOauth != "" {
			oauth = &boGetBoUsersOauth
		}
	}
	var jwtToken *string
	{
		if boGetBoUsersJWTToken != "" {
			jwtToken = &boGetBoUsersJWTToken
		}
	}
	v := &bo.GetBoUsersPayload{}
	v.Offset = offset
	v.Limit = limit
	v.Field = field
	v.Direction = direction
	v.Oauth = oauth
	v.JWTToken = jwtToken

	return v, nil
}

// BuildDeleteBoUserPayload builds the payload for the bo deleteBoUser endpoint
// from CLI flags.
func BuildDeleteBoUserPayload(boDeleteBoUserID string, boDeleteBoUserOauth string, boDeleteBoUserJWTToken string) (*bo.DeleteBoUserPayload, error) {
	var err error
	var id string
	{
		id = boDeleteBoUserID
		err = goa.MergeErrors(err, goa.ValidateFormat("id", id, goa.FormatUUID))

		if err != nil {
			return nil, err
		}
	}
	var oauth *string
	{
		if boDeleteBoUserOauth != "" {
			oauth = &boDeleteBoUserOauth
		}
	}
	var jwtToken *string
	{
		if boDeleteBoUserJWTToken != "" {
			jwtToken = &boDeleteBoUserJWTToken
		}
	}
	v := &bo.DeleteBoUserPayload{}
	v.ID = id
	v.Oauth = oauth
	v.JWTToken = jwtToken

	return v, nil
}

// BuildDeleteBoManyUsersPayload builds the payload for the bo
// deleteBoManyUsers endpoint from CLI flags.
func BuildDeleteBoManyUsersPayload(boDeleteBoManyUsersBody string, boDeleteBoManyUsersOauth string, boDeleteBoManyUsersJWTToken string) (*bo.DeleteBoManyUsersPayload, error) {
	var err error
	var body DeleteBoManyUsersRequestBody
	{
		err = json.Unmarshal([]byte(boDeleteBoManyUsersBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"tab\": [\n         \"Nemo eos soluta sed.\",\n         \"Necessitatibus sint.\",\n         \"Est sed molestiae et et quidem quae.\",\n         \"Est quis sapiente consequuntur aut est alias.\"\n      ]\n   }'")
		}
		if body.Tab == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("tab", "body"))
		}
		if err != nil {
			return nil, err
		}
	}
	var oauth *string
	{
		if boDeleteBoManyUsersOauth != "" {
			oauth = &boDeleteBoManyUsersOauth
		}
	}
	var jwtToken *string
	{
		if boDeleteBoManyUsersJWTToken != "" {
			jwtToken = &boDeleteBoManyUsersJWTToken
		}
	}
	v := &bo.DeleteBoManyUsersPayload{}
	if body.Tab != nil {
		v.Tab = make([]string, len(body.Tab))
		for i, val := range body.Tab {
			v.Tab[i] = val
		}
	}
	v.Oauth = oauth
	v.JWTToken = jwtToken

	return v, nil
}

// BuildUpdateBoUserPayload builds the payload for the bo updateBoUser endpoint
// from CLI flags.
func BuildUpdateBoUserPayload(boUpdateBoUserBody string, boUpdateBoUserID string, boUpdateBoUserOauth string, boUpdateBoUserJWTToken string) (*bo.UpdateBoUserPayload, error) {
	var err error
	var body UpdateBoUserRequestBody
	{
		err = json.Unmarshal([]byte(boUpdateBoUserBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"user\": {\n         \"avatar\": \"Architecto dolorem autem.\",\n         \"email\": \"guillaume@gmail.com\",\n         \"firstname\": \"Guillaume\",\n         \"lastname\": \"Morin\",\n         \"role\": \"admin\",\n         \"username\": \"guillaumemoriin\"\n      }\n   }'")
		}
		if body.User == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("user", "body"))
		}
		if body.User != nil {
			if err2 := ValidatePayloadUserRequestBody(body.User); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var id string
	{
		id = boUpdateBoUserID
		err = goa.MergeErrors(err, goa.ValidateFormat("id", id, goa.FormatUUID))

		if err != nil {
			return nil, err
		}
	}
	var oauth *string
	{
		if boUpdateBoUserOauth != "" {
			oauth = &boUpdateBoUserOauth
		}
	}
	var jwtToken *string
	{
		if boUpdateBoUserJWTToken != "" {
			jwtToken = &boUpdateBoUserJWTToken
		}
	}
	v := &bo.UpdateBoUserPayload{}
	if body.User != nil {
		v.User = marshalPayloadUserRequestBodyToBoPayloadUser(body.User)
	}
	v.ID = id
	v.Oauth = oauth
	v.JWTToken = jwtToken

	return v, nil
}

// BuildGetBoUserPayload builds the payload for the bo getBoUser endpoint from
// CLI flags.
func BuildGetBoUserPayload(boGetBoUserID string, boGetBoUserOauth string, boGetBoUserJWTToken string) (*bo.GetBoUserPayload, error) {
	var err error
	var id string
	{
		id = boGetBoUserID
		err = goa.MergeErrors(err, goa.ValidateFormat("id", id, goa.FormatUUID))

		if err != nil {
			return nil, err
		}
	}
	var oauth *string
	{
		if boGetBoUserOauth != "" {
			oauth = &boGetBoUserOauth
		}
	}
	var jwtToken *string
	{
		if boGetBoUserJWTToken != "" {
			jwtToken = &boGetBoUserJWTToken
		}
	}
	v := &bo.GetBoUserPayload{}
	v.ID = id
	v.Oauth = oauth
	v.JWTToken = jwtToken

	return v, nil
}
